(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./tml/src/DataFrame.js":
/*!******************************!*\
  !*** ./tml/src/DataFrame.js ***!
  \******************************/
/*! export DataFrame [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataFrame\": () => /* binding */ DataFrame\n/* harmony export */ });\n/*\n *  TIJS: Tools for ImageJ JavaScript\n *  Copyright (C) 2017-2019  Jean-Christophe Taveau.\n *\n *  This file is part of TIJS, module tml\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,Image\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with TIJS.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n * Authors:\n * Jean-Christophe Taveau\n */\n // Class\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DataFrame =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   */\n  function DataFrame() {\n    _classCallCheck(this, DataFrame);\n\n    // FloatProcessor\n    this._data;\n    this._width;\n    this._height;\n    this._rows;\n    this._columns;\n    /**\n     * Data Types:\n     * 1 = boolean\n     * 4 = date\n     * 6 = categorical\n     * 8 = byte\n     * 16 = 16-bit integer (pixel value)\n     * 24 = 24-bit RGB (pixel value)\n     * 32 = 32-bit float (pixel value)\n     * 64 = number\n     */\n\n    this._dtypes;\n    /**\n     * Categorical Data\n     * The categorical data are stored in a dictionary and only the index is stored in the underlying DataFrame/FloatProcessor\n     */\n\n    this._categoricals;\n  }\n\n  _createClass(DataFrame, [{\n    key: \"from\",\n    value: function from(data) {\n      // Step #1: check ResultsTable, ImagePlus, ImageProcessor, and ImageStack.\n      if (data[\"class\"]) {\n        this.fromIJ(data);\n      } //  Step #2: check \n      else if (data.columns) {\n          this.fromObject(data);\n        } //  Step #3: check matrix\n        else if (data[0] && data[0][0]) {\n            this.fromMatrix(data);\n          }\n    }\n  }, {\n    key: \"fromIJ\",\n    value: function fromIJ(data) {\n      var className = data[\"class\"].toString();\n\n      if (className.indexOf('ImagePlus') !== -1 && data.getNSlices() > 1) {\n        this.fromStack(data.getImageStack());\n      } else if (className.indexOf('ImagePlus') !== -1 && data.getNSlices() === 1) {\n        this.fromProcessor(data.getProcessor());\n      } else if (className.indexOf('ImagePlus') !== -1 && data.getNSlices() > 1) {\n        this.fromStack(data.getStack());\n      } else if (className.indexOf('Processor') !== -1) {\n        this.fromProcessor(data);\n      } else if (className.indexOf('ImageStack') !== -1) {\n        this.fromStack(data);\n      } else if (className.indexOf('ResultsTable') !== -1) {\n        this.fromResults(data);\n      } else if (className.indexOf('String') !== -1) {\n        this.fromTable(data);\n      } else {\n        IJ.showMessage('ERR: Cannot Load Data');\n        throw 'EXIT: End of Script';\n      }\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'row';\n      // TODO\n      this._rows = [];\n      this._columns = [];\n      this._dtypes = [];\n      var count = 0;\n\n      if (order == 'row') {\n        for (var key in Object.keys(json)) {\n          this._rows.push(key);\n\n          this._columns.push(count++);\n        }\n      } else if (order == 'column') {} else {\n        alert('Unknown order - Must be `row` or `column`');\n      }\n\n      this._data = new FloatProcessor(other);\n    }\n    /**\n     * Load 2D data (aka matrix) in DataFrame\n     */\n\n  }, {\n    key: \"fromMatrix\",\n    value: function fromMatrix(data) {// TODO\n    }\n  }, {\n    key: \"fromCSV\",\n    value: function fromCSV(data) {\n      var sep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';\n      // TODO \n      var flagIJ = false;\n      var table = data.split('\\n');\n      this._columns = table[0].split(sep);\n\n      if (this._columns[0].trim().length === 0) {\n        this._columns = this._columns.slice(1);\n        flagIJ = true;\n      }\n\n      this._width = this._columns.length;\n      this._height = table.length;\n      this._data = new FloatProcessor(this._width, this._height);\n      this._dtypes = Array.from({\n        length: table.length\n      }, function (_, i) {\n        return DataFrame.NUMBER;\n      });\n\n      if (flagIJ) {\n        this._rows = Array.from({\n          length: table.length\n        }, function (_, i) {\n          return i + 1;\n        });\n      } else {\n        this._rows = Array.from({\n          length: table.length\n        }, function (_, i) {\n          return 0;\n        });\n      } // Fill the data\n\n\n      for (var y = 1; y < table.length; y++) {\n        var row = table[y].split(sep);\n\n        for (var x = 0; x < row.length; x++) {\n          // TODO categorical\n          var v = isNaN(row[x]) ? -1 : parseFloat(row[x]);\n\n          this._data.setf(x, y - 1, v);\n        }\n      }\n    }\n  }, {\n    key: \"fromStack\",\n    value: function fromStack(stack) {\n      var w = stack.getWidth();\n      var h = stack.getHeight();\n      var num = stack.getSize();\n      this._data = new FloatProcessor(w * h, num);\n      this._width = w * h;\n      this._height = num;\n      this._dtypes = Array.from({\n        length: w\n      }, function (_) {\n        return stack.getBitDepth();\n      });\n      this._rows = Array.from({\n        length: this._height\n      }, function (_, i) {\n        return i + 1;\n      });\n      this._columns = Array.from({\n        length: this._width\n      }, function (_, i) {\n        return i;\n      }); // TODO A,B,....,Z, AA, ...AZ,BA, BB, ... ZZ, AAA, ... ZZZ\n\n      for (var z = 1; z <= num; z++) {\n        var ip = stack.getProcessor(z);\n\n        for (var i = 0; i < w * h; i++) {\n          this._data.setf(i, z - 1, ip.getf(i));\n        }\n      }\n    }\n  }, {\n    key: \"fromProcessor\",\n    value: function fromProcessor(ip) {\n      var w = ip.getWidth();\n      var h = ip.getHeight();\n      this._data = new FloatProcessor(w, h);\n      this._width = w;\n      this._height = h;\n      this._dtypes = Array.from({\n        length: w\n      }, function (_) {\n        return ip.getBitDepth();\n      });\n      this._rows = Array.from({\n        length: this._height\n      }, function (i, v) {\n        return i;\n      });\n      this._columns = Array.from({\n        length: this._width\n      }, function (i, v) {\n        return i;\n      }); // Copy Processor\n\n      for (var i = 0; i < w * h; i++) {\n        this._data.setf(i, ip.getf(i));\n      }\n    }\n  }, {\n    key: \"fromResults\",\n    value: function fromResults(table) {\n      var _this = this;\n\n      // HACK console.log('Results');\n      // Step #1: Read the ImageJ column headings\n      // In a ResultsTable, the first column is the row index and must be removed\n      this._columns = table.getColumnHeadings().split(/[\\t,]+/).slice(1);\n      this._rows = Array.from({\n        length: table.getColumn(0).length\n      }, function (_, i) {\n        return i + 1;\n      });\n      console.info(JSON.stringify(this._columns)); // Step #2: Guess types of columns\n\n      this._dtypes = Array.from({\n        length: this._columns.length\n      }, function (_) {\n        return DataFrame.NUMBER;\n      }); // Step #3: Fill the FloatProcessor\n\n      var w = this._columns.length;\n      var h = table.getColumn(0).length;\n      this._data = new FloatProcessor(w, h);\n      this._width = w;\n      this._height = h;\n\n      this._columns.forEach(function (heading, x) {\n        var idx = table.getColumnIndex(heading);\n        Java.from(table.getColumn(idx)).forEach(function (v, y) {\n          _this._data.setf(x, y, v);\n        });\n      });\n    }\n  }, {\n    key: \"fromTable\",\n    value: function fromTable(table_name) {\n      // Step #1: Read the ImageJ TextWindow and Extract values...\n      var win = WindowManager.getWindow(table_name);\n      var rows = win.getTextPanel().getText().split('\\n');\n      this._columns = rows[0].split('\\t'); // Step #2: Guess types of columns\n\n      this._dtypes = [];\n      var cells = rows[1].split('\\t');\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = cells[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var cell = _step.value;\n\n          this._dtypes.push(this._datatype(cell));\n        } // Step #3: Fill the FloatProcessor\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"array\",\n    value: function array() {\n      // TODO: replace the Categoricals and the booleans.\n      var tmp = toArrayJS(this._data.getFloatArray());\n      tmp = tmp.map(function (vec) {\n        return toArrayJS(vec);\n      });\n\n      if (this._width === 1) {\n        return tmp[0];\n      } // Need to transpose...\n\n\n      var out = [];\n\n      for (var i = 0; i < tmp[0].length; i++) {\n        out[i] = [];\n\n        for (var j = 0; j < tmp.length; j++) {\n          out[i][j] = tmp[j][i];\n        }\n      }\n\n      return out.length === 1 ? out[0] : out;\n    }\n    /**\n     * Get cell content from row and column.\n     * @param {string|number} row - row index (number) or row header (string)\n     * @param {string|number} row - row index (number) or row header (string)\n     * @returns {string|number} value (number,date, categorical,etc)\n     *\n     * @author Jean-Christophe Taveau\n     */\n\n  }, {\n    key: \"at\",\n    value: function at(row, col) {\n      var v, type;\n      var x = !isNaN(col) ? col : this._columns.indexOf(col);\n      var y = !isNaN(row) ? row : this._rows.indexOf(row);\n      type = this._dtypes[col];\n      v = this._data.getf(x, y); // TODO\n\n      return toType(v, type);\n    }\n  }, {\n    key: \"categorical\",\n    value: function categorical(categories) {\n      throw 'Not Yet Implemented';\n\n      if (this._categorical.includes(categories)) {}\n    }\n  }, {\n    key: \"icolumn\",\n    value: function icolumn(col) {\n      var index = col;\n      var df = new DataFrame();\n      df._width = 1;\n      df._height = this._height;\n      df._data = new FloatProcessor(1, this._height);\n      df._columns = [this._columns[index]];\n      df._rows = this._rows.map(function (r) {\n        return r;\n      }); // Copy\n\n      df._dtypes = [this._dtypes[index]];\n\n      for (var y = 0; y < this._height; y++) {\n        df._data.setf(0, y, this._data.getf(index, y));\n      } // TODO df._dtypes = this.dtypes.map( t => t);\n\n\n      return df;\n    }\n  }, {\n    key: \"column\",\n    value: function column(col) {\n      // TODO\n      var index = this._columns.indexOf(col);\n\n      if (index !== -1) {\n        return this.icolumn(index);\n      } else {\n        throw 'ERR: Unknown column heading';\n      }\n    }\n    /**\n     * Get sub-dataframe \n     */\n\n  }, {\n    key: \"iloc\",\n    value: function iloc(irows, icols) {\n      // TODO\n      var e = end === -1 ? this._height - 1 : end;\n      var w = icol_end === -1 ? this._width - icol_start + 1 : icol_end - icol_start + 1;\n      var h = irow_end === -1 ? this._height - irow_start + 1 : irow_end - irow_start + 1;\n      var ip = this._data;\n      ip.setRoi(0, start, w, h);\n      df._data = ip.crop(); // Update\n\n      df._columns = this._columns.filter(function (_, i) {\n        return i >= icol_start && i <= icol_end;\n      });\n      df._rows = this._rows.filter(function (_, i) {\n        return i >= irow_start && i <= irow_end;\n      });\n      df._dtypes = this._dtypes.filter(function (_, i) {\n        return i >= icol_start && i <= icol_end;\n      });\n      return df;\n    }\n    /**\n     * Get sub-dataframe\n     */\n\n  }, {\n    key: \"loc\",\n    value: function loc(row_start, row_end, col_start, col_end) {\n      throw 'Not Yet Implemented';\n    }\n    /**\n     * Get row from row index starting from 0 to length - 1\n     */\n\n  }, {\n    key: \"irow\",\n    value: function irow(i) {\n      // TODO\n      var df = new DataFrame(); // Use setRoi() and crop()\n      // let ip = this._data;\n      // ip.setRoi(0,i,this._width,1);\n      // df._data = ip.crop();\n\n      var _row = [];\n\n      for (var x = 0; x < this._width; x++) {\n        _row.push(this._data.getf(x, index));\n      } // HACK  console.log(_row.length);\n      // NASHORN Trick\n\n\n      df._data = new FloatProcessor(this._width, 1, Java.to(_row, \"float[]\"));\n      df._columns = this._columns.map(function (c) {\n        return c;\n      });\n      df._rows = this._rows === undefined ? index : [this._rows[index]];\n      df._dtypes = this._dtypes.map(function (t) {\n        return t;\n      });\n      return df;\n    }\n    /**\n     * Get row from row name\n     */\n\n  }, {\n    key: \"row\",\n    value: function row(row_name) {\n      // TODO Get row number from index\n      var i = this._rows.indexOf(row_name);\n\n      if (i !== -1) {\n        return irow(i);\n      } else {\n        throw 'ERR: Unknown row index/name';\n      }\n    }\n  }, {\n    key: \"irows\",\n    value: function irows() {\n      // TODO\n      var indexes;\n\n      for (var _len = arguments.length, indices = new Array(_len), _key = 0; _key < _len; _key++) {\n        indices[_key] = arguments[_key];\n      }\n\n      if (isNaN(indices[0]) && Array.isArray(indices[0])) {\n        indexes = indices[0];\n      } else {\n        indexes = indices;\n      }\n\n      var df = new DataFrame();\n      df._data = new FloatProcessor(this._width, indexes.length);\n      df._width = this._width;\n      df._height = indexes.length;\n      df._rows = new Array(indexes.length);\n      df._columns = this._columns.map(function (c) {\n        return c;\n      });\n      df._dtypes = this._dtypes.map(function (t) {\n        return t;\n      });\n\n      for (var i = 0; i < indexes.length; i++) {\n        var y = indexes[i];\n\n        for (var x = 0; x < this._width; x++) {\n          df._data.setf(x, i, this._data.getf(x, y));\n        } // Update\n\n\n        df._rows[i] = this._rows[y];\n      }\n\n      return df;\n    }\n  }, {\n    key: \"rows\",\n    value: function rows() {\n      var _this2 = this;\n\n      var indexes;\n\n      for (var _len2 = arguments.length, headings = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        headings[_key2] = arguments[_key2];\n      }\n\n      if (isNaN(headings[0]) && Array.isArray(headings[0])) {\n        indexes = headings[0];\n      } else {\n        indexes = headings;\n      }\n\n      var indices = indexes.map(function (heading) {\n        return _this2._rows.indexOf(heading);\n      });\n      this.irows.apply(this, _toConsumableArray(indices));\n    }\n  }, {\n    key: \"reshape\",\n    value: function reshape(nrows, ncols) {\n      // TODO\n      // Return a new rescaled DataFrame/FloatProcessor \n      var df = new DataFrame(); // NASHORN Trick\n\n      df._data = new FloatProcessor(ncols, nrows, this._data.getPixelsCopy());\n      df._columns = Array.from({\n        length: ncols\n      }, function (v, i) {\n        return i;\n      });\n      df._rows = Array.from({\n        length: nrows\n      }, function (v, i) {\n        return i;\n      }); // TODO df._dtypes = this.dtypes.map( t => t);\n\n      return df;\n    }\n  }, {\n    key: \"select\",\n    value: function select() {\n      var _this3 = this;\n\n      for (var _len3 = arguments.length, column_headings = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        column_headings[_key3] = arguments[_key3];\n      }\n\n      var ncols = column_headings.length;\n      var nrows = this._height; // HACK console.log(ncols);\n\n      var df = new DataFrame();\n      df._width = ncols;\n      df._height = nrows;\n      df._columns = column_headings;\n      df._dtypes = new Array(ncols);\n      df._data = new FloatProcessor(ncols, nrows);\n      column_headings.forEach(function (heading, x) {\n        var oldx = _this3._columns.indexOf(heading);\n\n        df._dtypes[x] = _this3._dtypes[oldx];\n\n        for (var y = 0; y < nrows; y++) {\n          var v = _this3._data.getf(oldx, y);\n\n          df._data.setf(x, y, v);\n        }\n      });\n      return df;\n    }\n    /**\n     * Select rows depending of the `predicate` function\n     */\n\n  }, {\n    key: \"where\",\n    value: function where(predicate) {\n      // TODO\n      var df = new DataFrame();\n      var ncols = column_names.length;\n      var nrows = this._rows;\n      df._data = new FloatProcessor(ncols, nrows, this._data.getPixelsCopy());\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = column_names[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var n = _step2.value;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return df;\n    }\n  }, {\n    key: \"transpose\",\n    value: function transpose(index) {\n      // TODO\n      // Return a new DataFrame/FloatProcessor \n      // Update _rows and _columns.\n      throw 'Not Yet Implemented';\n    }\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      // count,mean,std,min,25%,50%,75%,max\n      throw 'Not Yet Implemented';\n    }\n  }, {\n    key: \"mean\",\n    value: function mean() {\n      var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n\n      if (col === -1) {\n        // Compute mean for all the columns\n        throw 'Not Yet Implemented';\n      } else {\n        return this.column(col).array().reduce(function (mean, v) {\n          return mean + v;\n        }, 0.0) / this._height;\n      }\n    }\n  }, {\n    key: \"std\",\n    value: function std() {\n      throw 'Not Yet Implemented';\n    }\n    /**\n     * Print in console the first `n` rows\n     */\n\n  }, {\n    key: \"head\",\n    value: function head() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n      return this.toString(n);\n    }\n    /**\n     * Print in console the last `n` rows\n     */\n\n  }, {\n    key: \"tail\",\n    value: function tail() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n      return this.toString(-n);\n    }\n    /**\n     * Print in console\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var start = n < 0 ? Math.max(0, this._height + n) : 0;\n      var nrows = n <= 0 ? this._height : n;\n\n      var max_row_length = this._rows[this._rows.length - 1].toString().length;\n\n      var str = new Array(max_row_length + 2).fill(' ').join(''); // from({length:max_row_length + 2}, _ => ' ').join('');\n\n      this._columns.forEach(function (head) {\n        return str += head + '  ';\n      });\n\n      str += '\\n';\n\n      for (var i = start; i < nrows; i++) {\n        str += this._rows[i] + '| ';\n\n        for (var x = 0; x < this._width; x++) {\n          str += this._data.getf(x, i).toFixed(2) + ' ';\n        }\n\n        str += '\\n';\n      }\n\n      return str;\n    }\n    /**\n     * Only for debug\n     */\n\n  }, {\n    key: \"show\",\n    value: function show() {\n      var imp = new ImagePlus('DataFrame', this._data);\n      imp.show();\n    }\n    /*\n     * @private\n     */\n\n  }, {\n    key: \"_datatype\",\n    value: function _datatype(v) {\n      if (isNaN(v)) {\n        // Boolean?\n        if (['true', 'false'].indexOf(v.toLowerCase()) !== -1) {\n          return 1;\n        } // TODO Date?\n        // TODO RGB Color?\n        else if (v[0] === '#') {\n            return 24;\n          } // Categorical / String\n          else {\n              return 8;\n            }\n      } else {\n        return 32;\n      }\n    }\n  }, {\n    key: \"dtypes\",\n    get: function get() {\n      var _this4 = this;\n\n      var dataTypes = ['-', 'boolean', '-', '-', 'date', '-', 'category', '-', 'byte', '-', '-', '-', '-', '-', '-', '-', '-', 'int16', '-', '-', '-', '-', '-', '-', '-', '-', 'rgb-color', '-', '-', '-', '-', '-', '-', '-', '-', 'float', '-', '-', '-', '-', '-', '-', '-', '-', 'number'];\n      return this._dtypes.reduce(function (t, idx) {\n        return {\n          heading: _this4._columns[idx],\n          type: dataTypes[idx]\n        };\n      });\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this._height;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this._width;\n    }\n  }, {\n    key: \"shape\",\n    get: function get() {\n      return [this._height, this._width];\n    }\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this._rows;\n    },\n    set: function set(rows) {\n      // Copy\n      this._rows = rows.map(function (v) {\n        return v;\n      }); // Copy\n    }\n  }, {\n    key: \"headings\",\n    get: function get() {\n      return this._columns;\n    },\n    set: function set(cols) {\n      // Copy\n      this._columns = cols.map(function (v) {\n        return v;\n      });\n    }\n  }, {\n    key: \"columns\",\n    get: function get() {\n      return this.array();\n    }\n  }, {\n    key: \"rows\",\n    get: function get() {\n      return this.array();\n    }\n  }], [{\n    key: \"timestamp\",\n    value: function timestamp(a_date) {\n      // Number of seconds since 1970\n      // TODO\n      return 12345678;\n    }\n  }, {\n    key: \"BOOLEAN\",\n    value: function BOOLEAN() {\n      return 1;\n    }\n  }, {\n    key: \"alphabet\",\n    value: function alphabet() {\n      return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    }\n  }, {\n    key: \"NUMBER\",\n    get: function get() {\n      return 42;\n    }\n  }]);\n\n  return DataFrame;\n}(); // End of class DataFrame\n\n//# sourceURL=webpack:///./tml/src/DataFrame.js?");

/***/ }),

/***/ "./tml/src/Kmeans.js":
/*!***************************!*\
  !*** ./tml/src/Kmeans.js ***!
  \***************************/
/*! export Kmeans [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Kmeans\": () => /* binding */ Kmeans\n/* harmony export */ });\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ \"./tml/src/utilities.js\");\n/* harmony import */ var _DataFrame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataFrame */ \"./tml/src/DataFrame.js\");\n/*\n *  TIJS: Tools for ImageJ JavaScript\n *  Copyright (C) 2017-2019  Jean-Christophe Taveau.\n *\n *  This file is part of TIJS, module tml\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,Image\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with TIJS.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n * Authors:\n * Jean-Christophe Taveau\n */\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar sum = function sum(vec) {\n  return vec.reduce(function (accu, v) {\n    return accu + v;\n  }, 0.0);\n};\n\nvar Kmeans =\n/*#__PURE__*/\nfunction () {\n  function Kmeans(K) {\n    _classCallCheck(this, Kmeans);\n\n    this.K = K;\n    this.clusters = new Array(K);\n    this.centroids;\n  }\n  /**\n   * Fit model\n   *\n   * @param {DataFrame} - df Data in a DataFrame object   \n   * @param {string} - init Centroids initialization method: 'random' (default) or 'k-means++'\n   */\n\n\n  _createClass(Kmeans, [{\n    key: \"fit\",\n    value: function fit(df) {\n      var _this = this;\n\n      var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"k-means++\";\n      var distanceFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Kmeans.squaredEuclidean;\n      var getCentroids = {\n        'noise': this.noiseCentroids,\n        'random': this.randomCentroids,\n        'k-means++': this.kppCentroids\n      };\n      var vectors = df.array();\n      console.log(\"\".concat(vectors.length, \" x \").concat(vectors[0].length));\n      var assignments = new Array(vectors.length);\n      var model = {\n        assignments: undefined\n      };\n      var newModel = {\n        assignments: undefined\n      }; // Step #1 - Init Centroids\n\n      var centroids = getCentroids[init](vectors, this.K); // Step #2 - Iterative process\n\n      var iterations = 0;\n      var converged = this.assignmentsConverged;\n\n      while (converged(model, newModel) === false && iterations < 200) {\n        // Copy newModel into `model`\n        model = {\n          assignments: newModel.assignments !== undefined ? newModel.assignments.slice(0) : undefined\n        }; // update point-to-centroid assignments\n\n        var pot = 0;\n\n        for (var i = 0; i < vectors.length; i++) {\n          var tuple = Kmeans.nearestCentroid(vectors[i], centroids, distanceFunc);\n          assignments[i] = tuple[0];\n          pot += tuple[1];\n        }\n\n        if (assignments.indexOf(-1) !== -1) {\n          console.log('ERROR');\n        } // update location of each centroid\n\n\n        var _loop = function _loop(j) {\n          var assigned = Array.from({\n            length: vectors.length\n          }, function (_, i) {\n            return i;\n          }).filter(function (i) {\n            return assignments[i] === j;\n          });\n\n          if (!assigned.length) {\n            return \"continue\";\n          }\n\n          var centroid = centroids[j];\n          var newCentroid = new Array(centroid.length);\n\n          for (var _g = 0; _g < centroid.length; _g++) {\n            var _sum = 0;\n\n            for (var _i = 0; _i < assigned.length; _i++) {\n              _sum += vectors[assigned[_i]][_g];\n            }\n\n            newCentroid[_g] = _sum / assigned.length;\n            /*\n                          if (newCentroid[g] !== centroid[g]) {\n                             converged = false;\n                          }\n            */\n          }\n\n          centroids[j] = newCentroid;\n          _this.clusters[j] = assigned;\n        };\n\n        for (var j = 0; j < this.K; j++) {\n          var _ret = _loop(j);\n\n          if (_ret === \"continue\") continue;\n        }\n\n        iterations++;\n        console.log(\"Iteration #\".concat(iterations, \"  potential (phi): \").concat(pot));\n        this.best_potential = pot;\n        newModel = {\n          assignments: assignments\n        };\n      }\n\n      this.centroids = centroids;\n    }\n  }, {\n    key: \"potential\",\n    value: function potential() {\n      return this.best_potential;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"randomCentroids\",\n\n    /**\n     * @private\n     */\n    value: function randomCentroids(points, k) {\n      var centroids = points.slice(0); // copy\n\n      centroids.sort(function () {\n        return Math.round(Math.random()) - 0.5;\n      });\n      return centroids.slice(0, k);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"noiseCentroids\",\n    value: function noiseCentroids(points, k) {\n      var noise = function noise(len) {\n        return Array.from({\n          length: len\n        }, function (_, i) {\n          return Math.random() * 255;\n        });\n      };\n\n      console.log('noise');\n      return Array.from({\n        length: k\n      }, function (_, i) {\n        return noise(points[0].length);\n      });\n    }\n    /**\n     * k--means++ centroids \n     * Arthur, David and Sergei Vassilvitski (2007) \n     * K-means++: The Advantages of Careful Seeding. SODA 2007.\n     * Code adapted from Rosetta Code\n     */\n\n  }, {\n    key: \"kppCentroids\",\n    value: function kppCentroids(observations, n_clusters) {\n      var cumsum = function cumsum(data) {\n        return data.reduce(function (accu, d, i) {\n          var previous = i === 0 ? 0 : accu[i - 1];\n          accu.push(d + previous);\n          return accu;\n        }, []);\n      };\n\n      var sum = function sum(vec) {\n        return vec.reduce(function (accu, v) {\n          return accu + v;\n        }, 0.0);\n      };\n\n      var chooseNewCandidates = function chooseNewCandidates(cumulativeWeights, randoms) {\n        var candidates = new Array(randoms.length); // Compute Density Probability D2(x)\n\n        var _loop2 = function _loop2(trial) {\n          var r = randoms[trial];\n          var chosen = cumulativeWeights.findIndex(function (w) {\n            return w >= r;\n          });\n          candidates[trial] = chosen;\n        };\n\n        for (var trial = 0; trial < randoms.length; trial++) {\n          _loop2(trial);\n        }\n\n        return candidates;\n      };\n\n      var chooseNewCentroid = function chooseNewCentroid(weights, totalW) {\n        // Compute Density Probability D2(x)\n        var r = Math.random();\n        var cumulativeWeight = 0.0;\n\n        for (var i = 0; i < weights.length; i++) {\n          //\n          // use the uniform probability to search \n          // within the normalized weighting (we divide by totalWeight to normalize).\n          // once we hit the probability, we have found our index.\n          //\n          cumulativeWeight += weights[i] / totalW;\n\n          if (cumulativeWeight > r) {\n            return i;\n          }\n        }\n      };\n\n      var random_sample = function random_sample(num, min, max) {\n        return Array.from({\n          length: num\n        }, function (_) {\n          return Math.random() * (max - min) + min;\n        });\n      };\n\n      console.log('>>>> K-means++'); // Implementation adapted from scikit-learn/k_means\n\n      var n_local_trials = 2 + Math.floor(Math.log(n_clusters));\n      var centroid_ids = [];\n      var indexes = Array.from({\n        length: observations.length\n      }, function (_, i) {\n        return i;\n      }); // Array of all the closest distances to centroid.\n\n      var distances = Array.from({\n        length: observations.length\n      }, function (_, i) {\n        return -1;\n      }); // Step #1: Randomly choose the first centroid\n\n      var first = Math.floor(Math.random() * observations.length);\n      centroid_ids.push(first);\n      console.log('new centroid #0: ' + first);\n      var closest_dist_sq = Kmeans.nearestCentroids(observations, [observations[first]], Kmeans.squaredEuclidean).map(function (tuple) {\n        return tuple[1];\n      });\n      var current_pot = sum(closest_dist_sq);\n      console.log(current_pot); // Step #2: Choose k-1 centroids\n\n      for (var c = 1; c < n_clusters; c++) {\n        // Get `n_local_trials` random values\n        var rand_vals = random_sample(n_local_trials, 0, current_pot);\n        var candidate_ids = chooseNewCandidates(cumsum(closest_dist_sq), rand_vals); // console.log(`New Candidates: ${JSON.stringify(candidate_ids)}`);\n\n        var distance_to_candidates = candidate_ids.map(function (id) {\n          return Kmeans.nearestCentroids(observations, [observations[id]], Kmeans.squaredEuclidean).map(function (tuple) {\n            return tuple[1];\n          });\n        });\n        var best_candidate = undefined;\n        var best_pot = undefined;\n        var best_dist_sq = undefined;\n\n        for (var trial = 0; trial < n_local_trials; trial++) {\n          // Compute potential when including center candidate\n          var new_dist_sq = _utilities__WEBPACK_IMPORTED_MODULE_0__.minimum(closest_dist_sq, distance_to_candidates[trial]);\n          var new_pot = _utilities__WEBPACK_IMPORTED_MODULE_0__.sum(new_dist_sq); //  Store result if it is the best local trial so far\n\n          if (best_candidate === undefined || new_pot < best_pot) {\n            best_candidate = candidate_ids[trial];\n            best_pot = new_pot;\n            best_dist_sq = new_dist_sq;\n          }\n        } // Update\n\n\n        centroid_ids.push(best_candidate);\n        current_pot = best_pot;\n        closest_dist_sq = best_dist_sq;\n        console.log(\"\".concat(best_candidate, \" \").concat(best_pot));\n      }\n\n      console.log(JSON.stringify(centroid_ids));\n      return centroid_ids.map(function (c) {\n        return observations[c];\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"calcCentroid\",\n\n    /**\n     * @private\n     */\n    value: function calcCentroid(points, list) {\n      list.reduce(function (newCentroid, index) {\n        newCentroid[g] += points[index][g];\n        return newCentroid;\n      }, new Array(points[0].length).fill(0));\n\n      for (var _g2 = 0; _g2 < centroid.length; _g2++) {\n        var _sum2 = 0;\n\n        for (var i = 0; i < assigned.length; i++) {\n          _sum2 += assigned[i][_g2];\n        }\n\n        newCentroid[_g2] = _sum2 / assigned.length;\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"assignmentsConverged\",\n    value: function assignmentsConverged(model, newModel) {\n      var arraysEqual = function arraysEqual(a, b) {\n        if (a === undefined || b === undefined) return false;\n        if (a === null || b === null) return false;\n        if (a.length !== b.length) return false; // if (a === b) return true;\n        // If you don't care about the order of the elements inside\n        // the array, you should sort both arrays here.\n\n        for (var i = 0; i < a.length; ++i) {\n          if (a[i] !== b[i]) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      return arraysEqual(model.assignments, newModel.assignments);\n    }\n  }], [{\n    key: \"euclidean\",\n    value: function euclidean(v1, v2) {\n      var d2 = this.squaredEuclidean(v1, v2);\n      return Math.sqrt(d2);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"squaredEuclidean\",\n    value: function squaredEuclidean(v1, v2) {\n      return v1.reduce(function (accu, value, i) {\n        return accu + Math.pow(value - v2[i], 2);\n      }, 0.0);\n    }\n  }, {\n    key: \"nearestCentroid\",\n    value: function nearestCentroid(point, centroids, distanceFunc) {\n      var _min = Infinity;\n      var index = -1;\n\n      for (var i = 0; i < centroids.length; i++) {\n        var dist = distanceFunc(point, centroids[i]);\n\n        if (dist < _min) {\n          _min = dist;\n          index = i;\n        }\n      }\n\n      return [index, _min];\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"nearestIndexCentroid\",\n    value: function nearestIndexCentroid(point, centroids, distance) {\n      return Kmeans.nearestIndexDistanceCentroid(point, centroids, distance)[0];\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"nearestDistanceCentroid\",\n    value: function nearestDistanceCentroid(point, centroids, distance) {\n      return Kmeans.nearestIndexDistanceCentroid(point, centroids, distance)[1];\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"nearestCentroids\",\n    value: function nearestCentroids(points, centroids, distanceFunc) {\n      return points.map(function (p) {\n        return Kmeans.nearestCentroid(p, centroids, distanceFunc);\n      });\n    }\n  }]);\n\n  return Kmeans;\n}(); // End of class Kmeans\n\n//# sourceURL=webpack:///./tml/src/Kmeans.js?");

/***/ }),

/***/ "./tml/src/index.js":
/*!**************************!*\
  !*** ./tml/src/index.js ***!
  \**************************/
/*! export DataFrame [provided] [maybe used (runtime-defined)] [usage prevents renaming] */
/*! export Kmeans [provided] [maybe used (runtime-defined)] [usage prevents renaming] */
/*! other exports [not provided] [maybe used (runtime-defined)] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataFrame\": () => /* reexport safe */ _DataFrame__WEBPACK_IMPORTED_MODULE_0__.DataFrame,\n/* harmony export */   \"Kmeans\": () => /* reexport safe */ _Kmeans__WEBPACK_IMPORTED_MODULE_1__.Kmeans\n/* harmony export */ });\n/* harmony import */ var _DataFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataFrame */ \"./tml/src/DataFrame.js\");\n/* harmony import */ var _Kmeans__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Kmeans */ \"./tml/src/Kmeans.js\");\n/*\n *  TIJS: Tools for ImageJ JavaScript\n *  Copyright (C) 2017  Jean-Christophe Taveau.\n *\n *  This file is part of TIJS, module t8\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,Image\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with TIJS.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n * Authors:\n * Jean-Christophe Taveau\n */\n\n\n\n\n\n\n//# sourceURL=webpack:///./tml/src/index.js?");

/***/ }),

/***/ "./tml/src/utilities.js":
/*!******************************!*\
  !*** ./tml/src/utilities.js ***!
  \******************************/
/*! export minimum [provided] [no usage info] [missing usage info prevents renaming] */
/*! export sum [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"minimum\": () => /* binding */ minimum,\n/* harmony export */   \"sum\": () => /* binding */ sum\n/* harmony export */ });\n/*\n *  TIJS: Tools for ImageJ JavaScript\n *  Copyright (C) 2017-2019  Jean-Christophe Taveau.\n *\n *  This file is part of TIJS, module tml\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,Image\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with TIJS.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n * Authors:\n * Jean-Christophe Taveau\n */\n\n\nvar minimum = function minimum(a, b) {\n  return a.map(function (v, i) {\n    return v < b[i] ? v : b[i];\n  });\n};\nvar sum = function sum(vec) {\n  return vec.reduce(function (accu, v) {\n    return accu + v;\n  }, 0.0);\n};\n\n//# sourceURL=webpack:///./tml/src/utilities.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		var hasOwnProperty = Object.prototype.hasOwnProperty;
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(hasOwnProperty.call(definition, key) && !hasOwnProperty.call(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./tml/src/index.js");
/******/ })()
;
});